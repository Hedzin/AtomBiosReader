9602
06
01
      UCHAR ucDataRevision;
      UCHAR ucNumStates;
      UCHAR ucStateEntrySize;
      UCHAR ucClockInfoSize;
      UCHAR ucNonClockSize;
00
00
00
09
18

****9
      // offset from start of this table to array of ucNumStates ATOM_PPLIB_STATE structures
      USHORT usStateArrayOffset;
      // offset from start of this table to array of ASIC-specific structures,
      // currently ATOM_PPLIB_CLOCK_INFO.
      USHORT usClockInfoArrayOffset;
      // offset from start of this table to array of ATOM_PPLIB_NONCLOCK_INFO
      USHORT usNonClockInfoArrayOffset;
      USHORT usBackbiasTime;    // in microseconds
      USHORT usVoltageTime;     // in microseconds
      USHORT usTableSize;       //the size of this structure, or the extended structure
5800
6000
7d00
6b03
e803
5800
******21
		ULONG ulPlatformCaps;            // See ATOM_PPLIB_CAPS_*
00808200
*****25
12
00
00
02
00
3c
00
00
******33
      USHORT usBootClockInfoOffset;
      USHORT usBootNonClockInfoOffset;
6200
7f00
*****37
typedef struct _ATOM_PPLIB_POWERPLAYTABLE2
{
    ATOM_PPLIB_POWERPLAYTABLE basicTable;
    UCHAR   ucNumCustomThermalPolicy;
    USHORT  usCustomThermalPolicyArrayOffset;
}ATOM_PPLIB_POWERPLAYTABLE2, *LPATOM_PPLIB_POWERPLAYTABLE2;
00
af00
*****40
typedef struct _ATOM_PPLIB_POWERPLAYTABLE3
{
    ATOM_PPLIB_POWERPLAYTABLE2 basicTable2;
    USHORT                     usFormatID;                      // To be used ONLY by PPGen.
    USHORT                     usFanTableOffset;
    USHORT                     usExtendendedHeaderOffset;
} ATOM_PPLIB_POWERPLAYTABLE3, *LPATOM_PPLIB_POWERPLAYTABLE3;

1400
af00
ce00
******46
typedef struct _ATOM_PPLIB_POWERPLAYTABLE4
{
    ATOM_PPLIB_POWERPLAYTABLE3 basicTable3;
    ULONG                      ulGoldenPPID;                    // PPGen use only     
    ULONG                      ulGoldenRevision;                // PPGen use only
    USHORT                     usVddcDependencyOnSCLKOffset;
    USHORT                     usVddciDependencyOnMCLKOffset;
    USHORT                     usVddcDependencyOnMCLKOffset;
    USHORT                     usMaxClockVoltageOnDCOffset;
    USHORT                     usVddcPhaseShedLimitsTableOffset;    // Points to ATOM_PPLIB_PhaseSheddingLimits_Table
    USHORT                     usMvddDependencyOnMCLKOffset;  
} ATOM_PPLIB_POWERPLAYTABLE4, *LPATOM_PPLIB_POWERPLAYTABLE4;
3c050000
e31e0000
e800
1101
1701
0000
7101
0000


******66
typedef struct _ATOM_PPLIB_POWERPLAYTABLE5
{
    ATOM_PPLIB_POWERPLAYTABLE4 basicTable4;
    ULONG                      ulTDPLimit;
    ULONG                      ulNearTDPLimit;
    ULONG                      ulSQRampingThreshold;
    USHORT                     usCACLeakageTableOffset;         // Points to ATOM_PPLIB_CAC_Leakage_Table
    ULONG                      ulCACLeakage;                    // The iLeakage for driver calculated CAC leakage table
    USHORT                     usTDPODLimit;
    USHORT                     usLoadLineSlope;                 // in milliOhms * 100
} ATOM_PPLIB_POWERPLAYTABLE5, *LPATOM_PPLIB_POWERPLAYTABLE5;
00000000
00000000
00000000
4001
00000000
3200
0000
*********88
typedef struct _StateArray{
    //how many states we have 
    UCHAR ucNumEntries;
    
    ATOM_PPLIB_STATE_V2 states[1];
}StateArray;
02
typedef struct _ATOM_PPLIB_STATE_V2
{
      //number of valid dpm levels in this state; Driver uses it to calculate the whole 
      //size of the state: sizeof(ATOM_PPLIB_STATE_V2) + (ucNumDPMLevels - 1) * sizeof(UCHAR)
      UCHAR ucNumDPMLevels;
      
      //a index to the array of nonClockInfos
      UCHAR nonClockInfoIndex;
      /**
      * Driver will read the first ucNumDPMLevels in this array
      */
      UCHAR clockInfoIndex[1];
} ATOM_PPLIB_STATE_V2;
01
00
00

02
01
02
******95


00 ----&
******96

03
09
888a01f0
49020210
00382b01
f0490220
10003075
00983a00
000100

******125
02
18
typedef struct _ATOM_PPLIB_NONCLOCK_INFO
{
      USHORT usClassification;
      UCHAR  ucMinTemperature;
      UCHAR  ucMaxTemperature;
      ULONG  ulCapsAndSettings;
      UCHAR  ucRequiredPower;
      USHORT usClassification2;
      ULONG  ulVCLK;
      ULONG  ulDCLK;
      UCHAR  ucUnused[5];
} ATOM_PPLIB_NONCLOCK_INFO;

0800
00
00
00000000
00
0000
00000000
00000000
0000000000

0500
00
00
00000000
00
0000
00000000
00000000
00000000

******175

typedef struct _ATOM_PPLIB_FANTABLE
{
    UCHAR   ucFanTableFormat;                // Change this if the table format changes or version changes so that the other fields are not the same.
    UCHAR   ucTHyst;                         // Temperature hysteresis. Integer.
    USHORT  usTMin;                          // The temperature, in 0.01 centigrades, below which we just run at a minimal PWM.
    USHORT  usTMed;                          // The middle temperature where we change slopes.
    USHORT  usTHigh;                         // The high point above TMed for adjusting the second slope.
    USHORT  usPWMMin;                        // The minimum PWM value in percent (0.01% increments).
    USHORT  usPWMMed;                        // The PWM value (in percent) at TMed.
    USHORT  usPWMHigh;                       // The PWM value at THigh.
} ATOM_PPLIB_FANTABLE;
00
07
0668
104c
1df0
23d0
07c0
1210
typedef struct _ATOM_PPLIB_FANTABLE2
{
    ATOM_PPLIB_FANTABLE basicTable;
    USHORT  usTMax;                          // The max temperature
} ATOM_PPLIB_FANTABLE2;
27f0

23002800e412980800000000000000001a00f0490200400d03007a01de01230200004d0277020000000008307500e80350c30002ffa8100103ff284f0104ff2c5f0105ff3c6d0106ff847a0107ff888a0108ff01f049021a0408983a00e803983a0002ff983a0003fff0490204fff0490205fff0490206fff0490207fff0490208ff08c803c803c803cf03dc03dc03e803f403ee034c041a040e04780446043904a40471046504d6049d048b040105c204b60401e803307500983a00000a8cb9008cb900d8d600d8d60024f40024f400701101701101f82401f82401803801803801084c01084c01709400709400c0da00c0da00a86100a8610008e8030002ff0003ff0104ff0205ff0306ff0407ff0508ff0606030101010701080109010101000714cd007c920024f4008cb900341b019ce000444201ac0701cc5501f82401546901444201dc7c01905f0108e8030002ff0003ff0104ff0205ff0306ff0407ff0508ff060008e803c8af0002ffc8af0003ff14cd0004ff24f40005ff341b0106ffbc2e0107ff084c0108ff905f010008e803d8d60002ffd8d60003ffe8fd0004fff8240105ff084c0106ff905f0107ff18730108ffdc7c0101d000d700cc00000000003408480dd7005f00000000000000000000000000